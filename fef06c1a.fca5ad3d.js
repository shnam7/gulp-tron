(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{94:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return s}));var a=n(2),l=n(6),i=(n(0),n(98)),r={id:"builditem",title:"BuildItem"},c={unversionedId:"guide/builditem",id:"guide/builditem",isDocsHomePage:!1,title:"BuildItem",description:"BuildItem is an independent configuration object  that has 1-to-1 mapping to gulp task. Typically BuildItem is BuildConfig, but it can also be CleanerConfig or WatcherConfig object.",source:"@site/docs/guide/03-builditem.md",slug:"/guide/builditem",permalink:"/gulp-tron/guide/builditem",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/guide/03-builditem.md",version:"current",sidebar:"docs",previous:{title:"Concept",permalink:"/gulp-tron/guide/concept"},next:{title:"Builders",permalink:"/gulp-tron/guide/builders"}},o=[{value:"BuildConfig",id:"buildconfig",children:[{value:"conf.name",id:"confname",children:[]},{value:"conf.builder",id:"confbuilder",children:[]},{value:"conf.src",id:"confsrc",children:[]},{value:"conf.dest",id:"confdest",children:[]},{value:"conf.order",id:"conforder",children:[]},{value:"conf.outFile",id:"confoutfile",children:[]},{value:"conf.preBuild",id:"confprebuild",children:[]},{value:"conf.postBuild",id:"confpostbuild",children:[]},{value:"conf.buildOptions",id:"confbuildoptions",children:[]},{value:"conf.moduleOptions",id:"confmoduleoptions",children:[]},{value:"conf.dependencies",id:"confdependencies",children:[]},{value:"conf.triggers",id:"conftriggers",children:[]},{value:"conf.watch",id:"confwatch",children:[]},{value:"conf.addWatch",id:"confaddwatch",children:[]},{value:"conf.clean",id:"confclean",children:[]},{value:"conf.flushStream",id:"confflushstream",children:[]},{value:"conf.reloadOnChange",id:"confreloadonchange",children:[]},{value:"conf.verbose",id:"confverbose",children:[]},{value:"conf.silent",id:"confsilent",children:[]},{value:"conf.npmInstall",id:"confnpminstall",children:[]}]},{value:"CleanerConfig",id:"cleanerconfig",children:[{value:"conf.name",id:"confname-1",children:[]},{value:"conf.builder",id:"confbuilder-1",children:[]},{value:"conf.filter",id:"conffilter",children:[]},{value:"conf.sync",id:"confsync",children:[]}]},{value:"WatcherConfig",id:"watcherconfig",children:[{value:"conf.name",id:"confname-2",children:[]},{value:"conf.builder",id:"confbuilder-2",children:[]},{value:"conf.filter",id:"conffilter-1",children:[]},{value:"conf.browserSync",id:"confbrowsersync",children:[]},{value:"conf.livereload",id:"conflivereload",children:[]}]}],b={rightToc:o};function s(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"BuildItem is an independent configuration object  that has 1-to-1 mapping to gulp task. Typically BuildItem is BuildConfig, but it can also be CleanerConfig or WatcherConfig object."),Object(i.b)("h2",{id:"buildconfig"},"BuildConfig"),Object(i.b)("p",null,"Understanding BuildConfig object is be a starting point of learning gulp-tron. It is a configuration defining build process together with gulp task dependency hierarchy. There are pre-defiined set of properties, but users can add custom properties which can be used by the builder defined in it."),Object(i.b)("p",null,"BuildConfig object is resolved when it is added to gulp-tron project. In the resolving process, gulp task and RTB(Runtime Builder) instance are created, and all the dependencies defined in ",Object(i.b)("em",{parentName:"p"},"BuildConfig.triggers")," and ",Object(i.b)("em",{parentName:"p"},"BuildConfig.dependencies")," are also resolved in right sequence. The RTB instance is effectively a gulp task function object that has all the data required to run the build process. It is passed as first argument to all the build functions."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"interface BuildConfig {\n    name: string;                   // build name, mandatory field\n    builder?: BuilderType;          // main build operations in various form: function, object, class, etc\n    src?: string | string[];        // source for build operation\n    dest?: string;                  // output(destination) directory of the build operation\n    order?: string[];               // input file(src) ordering\n    outFile?: string;               // optional output file name\n    preBuild?: BuildFunction;       // function to be executed before BuildConfig.builder\n    postBuild?: BuildFunction;      // function to be executed after BuildConfig.builder\n    buildOptions?: Options;         // buildConfig instance specific custom options\n    moduleOptions?: Options;        // gulp module options\n    dependencies?: BuildSet;        // buildSet to be executed before this build task\n    triggers?: BuildSet;            // buildSet to be executed after this build task\n    watch?: string | string[];      // override default watch, 'src' if defined\n    addWatch?: string | string[];   // additional watch in addition to watch or default watch\n    clean?: string | string[];      // clean targets\n    flushStream?: boolean;          // finish all the output streams before exiting gulp task\n    reloadOnChange?: boolean;       // Reload on change when watcher is running. default is true.\n    verbose?: boolean,              // print verbose messages\n    silent?: boolean,               // depress informative messages\n    npmInstall?: string | string[]; // node packages to be installed by npm-auto-install option\n}\n")),Object(i.b)("p",null,"BuildConfig data can be accessed by ",Object(i.b)("em",{parentName:"p"},"conf")," property of RTB instance."),Object(i.b)("h3",{id:"confname"},"conf.name"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string")),Object(i.b)("p",null,"Specifies the name of build configuration. It is the only mandatory property of BuildConfig. This also specifies the name of gulp task to be created. So, this name should be unique globally. To avoid potential name collision, each project can have prefix which is automatically prefixed to the names of BuildConfig objects when they are resolved."),Object(i.b)("h3",{id:"confbuilder"},"conf.builder"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: BuilderType"),Object(i.b)("li",{parentName:"ul"},"default: () => {}")),Object(i.b)("p",null,"Executable which is the entry point of the gulp task to be created. Curently, following builder types are available."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"BuilderType"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"BuilderClassName"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Class name of built-in builder classes or the name of custom class inherited from GBuilder class. }")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"BuildFunction"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Function to be executed.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"ExternalCommand"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Object with external command and command line arguments.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"GBuilder"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Instance of Gbuilder or its deritive classes.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"'cleaner'"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Literal string 'cleaner' which means built-in in Clearner")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"'watcher'"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Literal string 'watcher' which means built-in Watcher.")))),Object(i.b)("p",null,"Refert to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"builders"}),"Builder")," section for details."),Object(i.b)("h3",{id:"confsrc"},"conf.src"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[]"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Glob path or array of glob paths that are referencing source files. rtb.src() creates gulp stream with this property. If no src specified, then no gulp stream is created."),Object(i.b)("h3",{id:"confdest"},"conf.dest"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string"),Object(i.b)("li",{parentName:"ul"},"default: process.cwd()")),Object(i.b)("p",null,"Output directory path. rtb.dest() writes the stream to the path sppecified in this property.If no value is specified, current process directory is used as output directory."),Object(i.b)("h3",{id:"conforder"},"conf.order"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string[]"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Specifies the order of files in input stream. If conf.src is not specified, this is ignored. For file ordering, 'gulp-order' module is used."),Object(i.b)("p",null,"As an example, ",Object(i.b)("inlineCode",{parentName:"p"},"['file2.js','*.js']")," specifies 'file2.js' to come first and all other '*.js' files to follow. Refer to the ","[gulp-order][1]"," site for the details."),Object(i.b)("h3",{id:"confoutfile"},"conf.outFile"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Output file name. This property can be optionally specified if some build process requires single output file name. For example, javascript builder can concatenate all the files in input stream into a single output file in the directory specified by conf.dest property."),Object(i.b)("h3",{id:"confprebuild"},"conf.preBuild"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: BuildFunction (See  ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"builders#buildfunction"}),"BuildFunction"),")"),Object(i.b)("li",{parentName:"ul"},"default: undefiined")),Object(i.b)("p",null,"Specifies a build function that will be executed before conf.builder. The three major build sequence functions, conf.preBuild, conf.builder, conf.postBuild are executed in sequence regardless of syncMode status. All those three functions can return promise which will be waited before moving to next steps."),Object(i.b)("p",null,"Example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const styles = {\n  name: 'styles',\n  builder: 'GCSSBuilder',\n  postBuild: rtb => rtb.copy({src:[otherStyleFiles], dest: destPath});\n};\n")),Object(i.b)("h3",{id:"confpostbuild"},"conf.postBuild"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: BuildFunction (See BuildConf.builder)"),Object(i.b)("li",{parentName:"ul"},"default: undefiined")),Object(i.b)("p",null,"Specifies a build function that will be executed after conf.builder. The three major build sequence functions, conf.preBuild, conf.builder, conf.postBuild are executed in sequence regardless of syncMode status. All those three functions can return promise which will be waited before moving to next steps."),Object(i.b)("h3",{id:"confbuildoptions"},"conf.buildOptions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: Options"),Object(i.b)("li",{parentName:"ul"},"default: {}")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"type Options = { [key: string]: any; }\n")),Object(i.b)("p",null,"Custom options used by conf.builder. Each builder can have its options here. However, there are common options typically used in general build proceses. For the options with the same purpose, it is recommended to use the same option names even for custom builders."),Object(i.b)("p",null,"For the options specific to each builders, you have to refer to the documentation of the builder."),Object(i.b)("p",null,"Following is an example of common options generally used across the builders."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"property"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"type"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"lint"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Enable lint")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"minify"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Generate minified output")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"minifyOnly"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Generate minified output and does not generate non-minified output")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"sourceMap"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Generate sourcemap files")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"postcss"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Enable PostCSS")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"babel"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Enable ES6/Babel transpiler")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"outFileOnly"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Generate single output file specified in conf.outFile only")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"prettify"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Prettify output (formatting)")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"printConfig"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"boolean"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Print any relevant config files")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"tsConfig"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"string"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"path to typescript config file")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"webpackConfig"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"string"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"path to webpack config file")))),Object(i.b)("h3",{id:"confmoduleoptions"},"conf.moduleOptions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: Options"),Object(i.b)("li",{parentName:"ul"},"default: {}")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"type Options = { [key: string]: any; }\n")),Object(i.b)("p",null,"Build operations typically use one or more gulp plugin modules. conf.moduleOptions property specifies the options to those modules. Each property name of conf.moduleOptions should be the same as the module name without 'gulp-' prefix. If module name has hyphens, then Camel Case should be used instead of the hyphens. For example, options for gulp-clean-css will be ",Object(i.b)("em",{parentName:"p"},"conf.moduleOptions.cleanCss"),". Options to gulp itself becomes ",Object(i.b)("em",{parentName:"p"},"conf.moduleOptions.gulp"),"."),Object(i.b)("h3",{id:"confdependencies"},"conf.dependencies"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"types: BuildSet"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"type BuildSet = BuildName | GulpTaskFunction | BuildItem | BuildSetSeries | BuildSetParallel;\ntype BuildSetSeries = BuildSet[];\ntype BuildSetParallel = { set: BuildSet[] };\n")),Object(i.b)("p",null,"Specifies other build configurations that will be executed before this build configuration in gulp task sequence. The dependencies can be any combination of build items in series or parallel. There is no limitation in the depth of dependency hierarchy. BuildSet is a recursive type which can have itself as its own dependendency."),Object(i.b)("p",null,"Examples: assume there are 5 independent build items (configurations): b1, b2, b3, b4, b5"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"conf.dependencies: tron.seres(b1, b2, tron.parallel(b3, b4, b5))"),Object(i.b)("li",{parentName:"ul"},"conf.dependencies: [b1, b[2, tron.parallel(","[b3, b4]",", b5))]")),Object(i.b)("p",null,"Note that tron.series() can be replaced with []. So, tron.series(a, b) can be simply expressed as ","[a, b]","."),Object(i.b)("h3",{id:"conftriggers"},"conf.triggers"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"types: BuildSet"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Specifies other build items that will be executed after this build configuration, in gulp task sequence. All the others are the same as conf.dependencies."),Object(i.b)("h3",{id:"confwatch"},"conf.watch"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[] | undefined"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Specifies watch target files that will be monitored by Watcher. Glob is supported. If this is not specified, conf.src is set as watch target of this configuration by default. To disable this automatic watching, set conf.watch to empty array, []."),Object(i.b)("h3",{id:"confaddwatch"},"conf.addWatch"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[]"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Addional watch targets that will be added in addition to conf.watch or default watch target, conf.src. Glob is supported."),Object(i.b)("h3",{id:"confclean"},"conf.clean"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[]"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Specifies clean targets that will be removed by Cleaner. Glob is supported."),Object(i.b)("h3",{id:"confflushstream"},"conf.flushStream"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: boolean"),Object(i.b)("li",{parentName:"ul"},"default: false")),Object(i.b)("p",null,"Normally, gulp task can be finished while the streams created during the build process are not finished yet. If conf.flushStream is set to true, the gulp taskwill not finish until all those streams are finished. For example, let assume task1 and task2 are configured to run in series, and task1 write a file and task2 access it. If task1 finishes and task2 starts when the file that task1 was writing is not finished, then task2 will fail to access the file during the build process. conf.flushStream option gurantees that the build task not to finish until all those file operations are finished."),Object(i.b)("h3",{id:"confreloadonchange"},"conf.reloadOnChange"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: boolean"),Object(i.b)("li",{parentName:"ul"},"default: true")),Object(i.b)("p",null,"Enable reloading when changes in watch target is detected. Default value is ture. To disable automatic reloading on change, this property should be set to ",Object(i.b)("strong",{parentName:"p"},"false")," exactly, not null or undefined."),Object(i.b)("h3",{id:"confverbose"},"conf.verbose"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: boolean"),Object(i.b)("li",{parentName:"ul"},"default: false")),Object(i.b)("p",null,"Enable extra message display."),Object(i.b)("h3",{id:"confsilent"},"conf.silent"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: boolean"),Object(i.b)("li",{parentName:"ul"},"default: false")),Object(i.b)("p",null,"Suppress non critical messages."),Object(i.b)("h3",{id:"confnpminstall"},"conf.npmInstall"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[]"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"List of modules to be automatically installed. The installation happens just before the build process starts. If auto-install option is not enabled, this option is ignoreed."),Object(i.b)("p",null,"Refer to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../getting-started/auto-install"}),"Automatic Module Installation")," for more details."),Object(i.b)("hr",null),Object(i.b)("h2",{id:"cleanerconfig"},"CleanerConfig"),Object(i.b)("p",null,"CleanerConfig is a special kind of BuildConfig, predefined to create cleaner task. Cleaner can be created by using BuildItem interface or using tron.addCleaner() function."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"interface CleanerConfig extends Pick<BuildConfig, \"clean\">, CleanOptions {\n    name?: string;                  // optional build name. if undefined, defaults to '@clean'\n    builder: 'cleaner',             // MUST be literal constant 'cleaner'\n    filter?: BuildNameSelector,     // filter for build names (inside the project) to be cleaned\n    sync?: boolean;                 // syncMode option. refer to class RTB.\n}\n")),Object(i.b)("p",null,"Example #1:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const tron = require('gulp-tron');\n\n//-- using BuildItem interface\nconst scss = { name: 'scss', builder: 'GCSSBuilder', /* ... */ }\nconst cleaner = { builder: 'cleaner' }      // buildItem with literal 'cleaner' as builder\ntron.createProject({scss, cleaner});\n\n//--- using gulp-tron API\ntron.createProject({scss}).addCleaner();       // this is equivalent to tron.createProject({scss}).addBuildItem(cleaner);\n")),Object(i.b)("p",null,"Example #2:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const tron = require('gulp-tron');\n\n// creates 3 cleaners: clean1, clean2, @clean\nconst clean1 = { name: 'clean1', builder: 'cleaner' }\nconst clean2 = { name: 'clean2', builder: 'cleaner', filter: [], clean: '*.dump' }\ntron.createProject({clean1, clean2}).addCleaner();\n")),Object(i.b)("h3",{id:"confname-1"},"conf.name"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | undefined"),Object(i.b)("li",{parentName:"ul"},"default: '@clean'")),Object(i.b)("p",null,"The same as BuildConfig.name except that it's optional. If not set, default name '@clean' is used as build name."),Object(i.b)("h3",{id:"confbuilder-1"},"conf.builder"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: 'cleaner'")),Object(i.b)("p",null,"The value for this should be set to literal string 'cleaner'."),Object(i.b)("h3",{id:"conffilter"},"conf.filter"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[] | RegExp | RegExp[];"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Cleanerr task cleans all the clean targets of build configurations within the project by default. If you want to clean selective build configurations only, you can specify the build name filter here."),Object(i.b)("h3",{id:"confsync"},"conf.sync"),Object(i.b)("p",null,"If set true, clean task does not finish until all the file operation (deleting) is finished."),Object(i.b)("hr",null),Object(i.b)("h2",{id:"watcherconfig"},"WatcherConfig"),Object(i.b)("p",null,"WatcherConfig is a special kind of BuildConfig, predefined to create watcher task. Watcher can be created by using BuildItem interface or using tron.addWatcher() function."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"interface WatcherConfig extends Pick<BuildConfig, \"watch\"> {\n    name?: string;                  // optional build name. if undefined, defaults to '@watch'\n    builder: 'watcher',             // MUST be literal constant 'cleaner'\n    filter?: BuildNameSelector,     // filter for build names (inside the project) to be watched\n    browserSync?: ReloaderOptions;  // browserSync initializer options\n    livereload?: ReloaderOptions;   // livereload initializer options\n    watch?: string | string[];      // additional watch targets\n}\n")),Object(i.b)("p",null,"Example #1:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const tron = require('gulp-tron');\n\n//-- using BuildItem interface\nconst scss = { name: 'scss', builder: 'GCSSBuilder', /* ... */ }\nconst watcher = { builder: 'watcher' }      // buildItem with literal 'watcher' as builder\ntron.createProject({scss, watcher});\n\n//--- using gulp-tron API\ntron.createProject({scss}).addWatch();   // Or, tron.createProject({scss}).addBuildItem(watcher);\n")),Object(i.b)("h3",{id:"confname-2"},"conf.name"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | undefined"),Object(i.b)("li",{parentName:"ul"},"default: '@watch'")),Object(i.b)("p",null,"The same as BuildConfig.name except that it's optional. If not set, default name '@watch' is used as build name."),Object(i.b)("h3",{id:"confbuilder-2"},"conf.builder"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: 'watcher'")),Object(i.b)("p",null,"The value for this should be set to literal string 'watcher'."),Object(i.b)("h3",{id:"conffilter-1"},"conf.filter"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"type: string | string[] | RegExp | RegExp[];"),Object(i.b)("li",{parentName:"ul"},"default: undefined")),Object(i.b)("p",null,"Watcher task watches all the build configurations within the project by default. If you want to watch selective build configurations only, you can specify the build name filter here."),Object(i.b)("h3",{id:"confbrowsersync"},"conf.browserSync"),Object(i.b)("p",null,"browserSync initializer options. Refer to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.browsersync.io/docs/options"}),"browser-sync")," for the details. browser-sync is activated when this property is set properly and the project's watch target list is not empty."),Object(i.b)("h3",{id:"conflivereload"},"conf.livereload"),Object(i.b)("p",null,"livereload initializer options. Refer to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/vohof/gulp-livereload#api--variables"}),"gulp-livereload")," for the details. livereload is activated when this property is set properly and the project's watch target list is not empty."))}s.isMDXComponent=!0},98:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return f}));var a=n(0),l=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var b=l.a.createContext({}),s=function(e){var t=l.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=s(e.components);return l.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},p=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,b=o(e,["components","mdxType","originalType","parentName"]),u=s(n),p=a,f=u["".concat(r,".").concat(p)]||u[p]||d[p]||i;return n?l.a.createElement(f,c(c({ref:t},b),{},{components:n})):l.a.createElement(f,c({ref:t},b))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,r[1]=c;for(var b=2;b<i;b++)r[b]=n[b];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);